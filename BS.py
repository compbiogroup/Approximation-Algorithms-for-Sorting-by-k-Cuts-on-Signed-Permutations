##########################################################################
#              "python3 BS.py <inputFile> <outputFile> <k>"              #
##########################################################################
# -inputFile  : path of the input file, generated by generate-k.sh       #
# -outputFile : path of the output file, where results will be printed   #
# -k          : an integer number greater than or equal to 5             #
##########################################################################


import sys
import time

def last_kcut(perm, k) :
    ops = [-1 for _ in range(k)]
    i = 0
    j = 0
    middle_strips = [[0,0],]
    while i < len(perm) :
        while (i < len(perm)-1) and (perm[i+1] == perm[i]+1) :
            i += 1
        ops[j] = i+1
        i += 1
        if j+1 > 0 and j+1 < k and i < len(perm) :
            if perm[i] < 0 :
                middle_strips.append([-perm[i],-j-1])
            else :
                middle_strips.append([perm[i],j+1])
        j += 1
        if j == k :
            break
    middle_strips.append([len(perm),len(middle_strips)])
    middle_strips.sort()
    while len(ops) < k :
        ops = ops + [ops[-1]]
        middle_strips.append([len(perm),len(middle_strips)])

    kpermp = [i[1] for i in middle_strips]

    blocos = [perm[0:ops[0]],]
    for i in range(1,len(ops)) :
        blocos = blocos + [perm[ops[i-1]:ops[i]]]
    blocos = blocos + [perm[ops[-1]:]]
    perm = []
    for i in kpermp :
        if i < 0 :
            perm = perm + [-el for el in blocos[-i][::-1]]
        else :
            perm = perm + blocos[i]
    return perm, [ops,kpermp[1:-1]]

def num_bp(perm) :
    bp = 0
    for i in range(1,len(perm)) :
        if perm[i] != perm[i-1]+1 :
            bp = bp + 1
    return bp

def lower_bound(perm, k) :
    return float(num_bp(perm))/float(k)

def is_sorted(perm) :
    for i in range(1,len(perm)) :
        if perm[i] != perm[i-1]+1 :
            return False
    return True

def get_positions(perm) :
    pos = [-1 for i in range(len(perm))]
    for i in range(len(perm)) :
        pos[abs(perm[i])] = i
    return pos

def get_positions2(perm) :
    pos = [-1 for i in range(len(perm))]
    for i in range(len(perm)) :
        if perm[i] >= 0 :
            pos[abs(perm[i])] = i
        else :
            pos[abs(perm[i])] = -i
    return pos

def find_next_strip(next_strip_element, perm, pos) :
    tam = len(perm)
    start = pos[next_strip_element]
    if perm[start] < 0 :
        is_Positive = False
        end = start+1
        while (start > 0) and (perm[start-1] == perm[start]-1) :
            start = start-1
    else :
        is_Positive = True
        end = start
        while ((end + 1) < (tam - 1)) and (perm[end+1] == perm[end]+1) :
            end = end + 1
        end = end + 1
    return start, end, is_Positive

def find_strip_point(perm, ini) :
    tam = len(perm)
    if ini == True :
        start = 0
        end = 0
        while (end+1 < tam-1) and (perm[end+1] == perm[end]+1) :
            end = end + 1
    else :
        end = tam-1
        start = end
        while (start > 0) and (perm[start-1] == perm[start]-1) :
            start = start - 1
    return start, end

def sort(perm,k,inicio,arqout) :
    seq = []
    lb = lower_bound(perm, k)
    while num_bp(perm) > k : 
        positions = get_positions(perm)
        FIRSTs, FIRSTe = find_strip_point(perm, True)
        LASTs, LASTe = find_strip_point(perm, False)
        first_cut = FIRSTe + 1
        k_available = k-1
        next_strip_element = perm[first_cut-1]+1
        op = [first_cut,]
        middle_strips = []
        middle_strips2 = []
        # we will add another strip if we can cut at least two positions
        # and the next strip is not the rightmost one
        while (k_available > 1) and (next_strip_element != perm[LASTs]) :
            ini, end, isPos = find_next_strip(next_strip_element, perm, positions)
            op = op + [ini, end]
            if isPos :
                next_strip_element = perm[end-1]+1
                middle_strips.append([ini,end,(len(middle_strips)+1)])
                middle_strips2.append([ini,end])
            else :
                next_strip_element = abs(perm[ini])+1
                middle_strips.append([ini,end,-(len(middle_strips)+1)])
                middle_strips2.append([ini,end])
            k_available = k_available - 2
        # increasing the number of cuts if it is not yet k
        ops = sorted(op)
        for i in range(1,len(ops)) :
            if [ops[i-1],ops[i]] not in middle_strips2 :
                middle_strips.append([ops[i-1],ops[i],len(middle_strips)+1])
        middle_strips.sort(key=lambda x: (x[0], x[1]))
        while len(ops) < k :
            ops = ops + [ops[-1]]
            middle_strips.append([ops[-1],ops[-1],(len(middle_strips)+1)])
        kperm = [0] + [i[2] for i in middle_strips] + [len(middle_strips)+1]
        kpermp = get_positions2(kperm)
        # creating blocks
        blocos = [perm[0:ops[0]],]
        for i in range(1,len(ops)) :
            blocos = blocos + [perm[ops[i-1]:ops[i]]]
        blocos = blocos + [perm[ops[-1]:]]
        # reordering blocks
        perm = []
        for i in kpermp :
            if i < 0 :
                perm = perm + [-el for el in blocos[-i][::-1]]
            else :
                perm = perm + blocos[i]
        seq.append([ops,kperm[1:-1]])

    if is_sorted(perm) == False :
        perm, last =  last_kcut(perm, k)
        seq.append(last)
        if is_sorted(perm) == False :
            print("ERRO!")
            sys.exit(0)

    tam_seq = len(seq)
    print(tam_seq, str(seq).replace(" ",""), float(tam_seq)/lb, time.time()-inicio, file = arqout)


if __name__ == '__main__':

    inputPath = sys.argv[1]
    outputPath = sys.argv[2]
    k_value = int(sys.argv[3])

    arqperms = open(inputPath, 'r')
    arqout = open(outputPath, 'a')
    while True:
        line = arqperms.readline()
        if not line :
            break
        perm, ops = line.split(' ')
        permutation = eval("[%s]" % perm)
        permutation = [0] + permutation + [len(permutation)+1]
        sort(permutation,k_value,time.time(),arqout)
    arqperms.close()
    arqout.close()

